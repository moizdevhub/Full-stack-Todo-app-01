# Implementation Plan: AI-Powered Todo Chatbot

**Branch**: `001-ai-todo-chatbot` | **Date**: 2026-01-24 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-ai-todo-chatbot/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build an AI-powered conversational todo management system that enables users to create, view, complete, update, and delete tasks using natural language. The system uses a stateless architecture with OpenAI Agents SDK for natural language understanding, FastMCP for tool-based task operations, and Neon PostgreSQL for persistent storage. The frontend uses OpenAI ChatKit UI for the chat interface, while the backend is built with Python FastAPI. Every request reconstructs context from the database to maintain statelessness, and all operations are strictly scoped by user_id for data isolation.

## Technical Context

**Language/Version**: Python 3.13+ (backend), TypeScript/Next.js (frontend)
**Primary Dependencies**:
- Backend: FastAPI, FastMCP (Official Python MCP SDK), SQLModel, OpenAI Agents SDK
- Frontend: Next.js, OpenAI ChatKit UI, React
- AI: Gemini API via OpenAI-compatible endpoint

**Storage**: Neon Serverless PostgreSQL (stateless architecture - DB is sole source of truth)
**Testing**: pytest (backend), Jest/React Testing Library (frontend)
**Target Platform**: Web application (Vercel for frontend, Railway/Render for backend)
**Project Type**: Web (frontend + backend separation)
**Performance Goals**:
- Task creation response < 3 seconds
- 95% intent interpretation accuracy
- Support concurrent users without degradation

**Constraints**:
- Stateless: No in-memory sessions; every request reconstructs context from DB
- Data isolation: All operations strictly scoped by user_id
- No voice input, no notifications, no task prioritization

**Scale/Scope**:
- Multi-user system with complete data isolation
- Conversation history persistence for contextual understanding
- 5 core operations: create, list, complete, delete, update tasks

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Core Principles Compliance

✅ **Agentic Development**: All code will be generated by agents (implementation-executor)
✅ **Spec-Driven Development**: Following spec → plan → tasks → implement workflow
✅ **GitHub MCP Integration**: All Git operations via MCP (sp.git.commit_pr agent)
✅ **Test-Driven Development**: 80%+ coverage requirement enforced

### Production Standards Compliance (Section VIII - MANDATORY)

**Applicability**: ✅ **ACTIVE** - This feature uses production web stack (Next.js + FastAPI + Neon)

#### 8.1 Authentication & Authorization
✅ **Status**: COMPLIANT
- All FastAPI endpoints will use `@require_auth` decorator
- JWT validation from Better Auth (user_id extraction from `sub` claim)
- 401 responses for missing/invalid tokens

#### 8.2 Data Segregation
✅ **Status**: COMPLIANT
- All database queries filtered by `user_id` from JWT
- SQLModel filters automatically scope by authenticated user
- No global queries (all operations user-scoped)

#### 8.3 Secret Management
✅ **Status**: COMPLIANT
- JWT secret in environment variables only (Vercel + Railway/Render)
- No secrets in code, logs, or repository
- `.env` files in `.gitignore`

#### 8.4 API Stability
✅ **Status**: COMPLIANT
- Versioned API paths: `/api/v1/{user_id}/chat`
- Backward compatibility maintained within major version
- Breaking changes require major version bump

#### 8.5 Error Contract
✅ **Status**: COMPLIANT
- Standardized JSON error responses: `{error, code, timestamp}`
- No stack traces in production responses
- Consistent error codes across endpoints

#### 8.6 Type Safety
✅ **Status**: COMPLIANT
- TypeScript strict mode enabled (`tsconfig.json`)
- Python mypy --strict for all FastAPI code
- All function signatures fully typed

#### 8.7 UV Package Manager
✅ **Status**: COMPLIANT
- All Python dependencies via UV
- `pyproject.toml` + `uv.lock` committed
- No pip/poetry/pipenv usage

#### 8.8 DB Migration Hygiene
✅ **Status**: COMPLIANT
- All schema changes via Alembic migrations
- Migrations committed to repository
- Idempotent migrations with upgrade/downgrade functions

#### 8.9 Testing Gates
✅ **Status**: COMPLIANT
- pytest coverage ≥ 80% for backend
- Jest coverage for frontend critical paths
- E2E tests for core CRUD operations

### Gate Result: ✅ **PASS** - All constitutional requirements satisfied

## Project Structure

## Project Structure

### Documentation (this feature)

```text
specs/001-ai-todo-chatbot/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (in progress)
├── research.md          # Phase 0 output (to be created)
├── data-model.md        # Phase 1 output (to be created)
├── quickstart.md        # Phase 1 output (to be created)
├── contracts/           # Phase 1 output (to be created)
│   ├── api.openapi.yaml # OpenAPI spec for FastAPI endpoints
│   └── mcp-tools.json   # MCP tool definitions
├── checklists/          # Quality validation
│   └── requirements.md  # Spec quality checklist (completed)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── models/
│   │   ├── task.py           # Task SQLModel
│   │   ├── conversation.py   # Conversation SQLModel
│   │   └── message.py        # Message SQLModel
│   ├── services/
│   │   ├── database.py       # Neon PostgreSQL connection
│   │   ├── auth.py           # JWT validation middleware
│   │   └── context.py        # Context reconstruction from DB
│   ├── mcp/
│   │   ├── server.py         # FastMCP server implementation
│   │   └── tools.py          # MCP tool definitions (add_task, list_tasks, etc.)
│   ├── agent/
│   │   ├── runner.py         # OpenAI Agent + Runner setup
│   │   └── config.py         # Agent configuration (Gemini endpoint)
│   └── api/
│       ├── main.py           # FastAPI app entry point
│       ├── routes.py         # /api/v1/{user_id}/chat endpoint
│       └── schemas.py        # Pydantic request/response models
├── tests/
│   ├── unit/
│   │   ├── test_models.py
│   │   ├── test_mcp_tools.py
│   │   └── test_auth.py
│   ├── integration/
│   │   ├── test_chat_endpoint.py
│   │   └── test_context_reconstruction.py
│   └── conftest.py
├── alembic/
│   ├── versions/             # Database migrations
│   └── env.py
├── pyproject.toml            # UV dependencies
├── uv.lock                   # UV lock file
└── .env.example              # Environment variable template

frontend/
├── src/
│   ├── app/
│   │   ├── page.tsx          # Main chat interface
│   │   └── layout.tsx        # App layout
│   ├── components/
│   │   ├── ChatInterface.tsx # OpenAI ChatKit integration
│   │   ├── MessageList.tsx   # Message display
│   │   └── InputBox.tsx      # User input
│   ├── services/
│   │   ├── api.ts            # Backend API client
│   │   └── auth.ts           # Better Auth integration
│   └── types/
│       └── chat.ts           # TypeScript interfaces
├── tests/
│   └── components/
│       └── ChatInterface.test.tsx
├── package.json
├── tsconfig.json             # TypeScript strict mode
└── .env.local.example
```

**Structure Decision**: Web application structure with separate backend and frontend directories. Backend uses FastAPI with MCP server for tool-based operations and OpenAI Agents SDK for natural language understanding. Frontend uses Next.js with OpenAI ChatKit UI for the chat interface. This separation enables independent deployment (Vercel for frontend, Railway/Render for backend) and clear API boundaries.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**Status**: No violations detected. All constitutional requirements are satisfied without exceptions.

This feature complies with all core principles and production standards (Section VIII). No complexity justifications required.

---

## Phase 0: Research Summary

**Status**: ✅ **COMPLETE**

**Artifacts Created**:
- `research.md` - Technology choices, best practices, and architectural decisions

**Key Decisions**:
1. **Gemini API via OpenAI-Compatible Endpoint**: Cost-effective LLM with function calling support
2. **FastMCP for Stateless MCP Server**: Official Python SDK with structured tool definitions
3. **OpenAI Agents SDK**: Agent + Runner pattern for natural language understanding
4. **Stateless Architecture**: Context reconstruction from database on every request
5. **Better Auth JWT Validation**: Secure authentication at API boundary
6. **Separate Frontend/Backend Deployment**: Independent scaling and deployment

**Research Areas Covered**:
- Gemini API configuration and compatibility
- FastMCP stateless mode implementation
- OpenAI Agents SDK integration patterns
- OpenAI ChatKit UI React components
- Context reconstruction strategies
- JWT validation middleware
- Database performance optimization

**Risk Mitigation Strategies**:
- Gemini API compatibility testing with fallback to OpenAI
- Database connection pooling for performance
- JWT secret management and rotation
- Cross-user data leakage prevention
- ChatKit UI evaluation with custom component fallback

---

## Phase 1: Design & Contracts Summary

**Status**: ✅ **COMPLETE**

**Artifacts Created**:
- `data-model.md` - Database entities, relationships, and validation rules
- `contracts/api.openapi.yaml` - OpenAPI specification for REST endpoints
- `contracts/mcp-tools.json` - MCP tool definitions and schemas
- `quickstart.md` - Development setup and deployment guide
- `CLAUDE.md` - Updated agent context with new technologies

**Data Model**:
- **Task**: User tasks with title, description, completion status
- **Conversation**: Chat sessions between user and AI assistant
- **Message**: Individual messages in conversations (user/assistant)
- All entities include `user_id` for data isolation
- Comprehensive indexes for query performance

**API Contracts**:
- **POST /{user_id}/chat**: Main chat endpoint with context reconstruction
- **GET /{user_id}/conversations**: List user conversations
- **POST /{user_id}/conversations**: Create new conversation
- **GET /{user_id}/conversations/{id}**: Get conversation with message history
- Standardized error responses with error codes

**MCP Tools**:
- **add_task**: Create new task with title and optional description
- **list_tasks**: Retrieve tasks with status filtering (all/pending/completed)
- **complete_task**: Mark task as completed
- **delete_task**: Permanently remove task
- **update_task**: Modify task title or description
- All tools require `user_id` for data isolation

**Development Setup**:
- Backend: Python 3.13+, FastAPI, FastMCP, SQLModel, Alembic
- Frontend: Next.js 14+, OpenAI ChatKit, TypeScript strict mode
- Database: Neon PostgreSQL with connection pooling
- Testing: pytest (backend), Jest (frontend), 80%+ coverage requirement
- Deployment: Vercel (frontend), Railway/Render (backend)

---

## Phase 2: Task Breakdown

**Status**: ⏭️ **PENDING** - Run `/sp.tasks` command to generate tasks.md

**Next Steps**:
1. Run `/sp.tasks` to break down implementation into testable tasks
2. Review and approve task breakdown
3. Run `/sp.implement` to execute tasks
4. Run code quality validation
5. Create PR via `/sp.git.commit_pr`

---

## Implementation Priorities

### P0: Core Infrastructure (Must Have)
1. Database models and migrations (Task, Conversation, Message)
2. Neon PostgreSQL connection with connection pooling
3. JWT validation middleware with Better Auth integration
4. FastAPI app structure with error handling

### P0: MCP Server (Must Have)
1. FastMCP server setup with stateless configuration
2. Implement 5 MCP tools (add, list, complete, delete, update)
3. User_id scoping and ownership verification
4. Error handling with standardized error codes

### P0: AI Agent (Must Have)
1. OpenAI Agents SDK integration with Gemini endpoint
2. Agent instructions and tool registration
3. Context reconstruction from database
4. Tool execution and response generation

### P0: API Endpoint (Must Have)
1. POST /{user_id}/chat endpoint implementation
2. Request/response Pydantic schemas
3. Conversation and message persistence
4. Error handling and validation

### P1: Frontend (Should Have)
1. Next.js app setup with TypeScript strict mode
2. OpenAI ChatKit integration
3. API client with authentication
4. Better Auth integration

### P1: Testing & Deployment (Should Have)
1. Unit tests with 80%+ coverage
2. Integration tests for E2E flows
3. Deployment configuration (Vercel + Railway/Render)
4. Environment variable setup and documentation

---

## Success Criteria

### Functional Success
- ✅ All 5 MCP tools implemented and working
- ✅ Chat endpoint accepts natural language and returns AI responses
- ✅ Context reconstruction from database on every request
- ✅ Data isolation enforced (user_id filtering on all queries)
- ✅ Conversation history persisted and retrievable

### Technical Success
- ✅ All constitutional requirements satisfied (Section VIII compliance)
- ✅ Type safety enforced (TypeScript strict + mypy --strict)
- ✅ 80%+ test coverage for backend
- ✅ JWT authentication working at all API boundaries
- ✅ Database migrations replayable from scratch

### Quality Success
- ✅ Code passes code-quality-validator review
- ✅ No security violations (AuthN/AuthZ, secrets, data segregation)
- ✅ API contracts documented (OpenAPI spec)
- ✅ Development setup documented (quickstart.md)
- ✅ Clean git history with conventional commits

---

## Planning Complete

**Branch**: `001-ai-todo-chatbot`
**Plan File**: `specs/001-ai-todo-chatbot/plan.md`

**Artifacts Generated**:
1. ✅ `plan.md` - This implementation plan
2. ✅ `research.md` - Technology research and decisions
3. ✅ `data-model.md` - Database schema and entities
4. ✅ `contracts/api.openapi.yaml` - REST API specification
5. ✅ `contracts/mcp-tools.json` - MCP tool definitions
6. ✅ `quickstart.md` - Development setup guide
7. ✅ `CLAUDE.md` - Updated agent context

**Ready for Next Phase**: Run `/sp.tasks` to generate task breakdown and begin implementation.
